import "utils/pack/u32/nonStrictUnpack256.zok" as unpack
import "utils/pack/u32/pack256.zok" as pack
import "hashes/sha256/1024bit.zok" as sha256of1024

// amountA: the amount contained in the commitmentA (public)
// nullifierA: the nullifier for the commitmentA (public)
// rootA: the Merkle root of commitmentA (public)
// secretKey: the secret key for the commitmentA and commitmentB (private)
// randomA: token random nonce for the commitmentA (private)
// pathA: the Merkle path for the commitmentA (private)

// amountB: the amount contained in the commitmentB (public)
// nullifierB: the nullifier for the commitmentB (public)
// rootB: the Merkle root of commitmentB (public)
// randomB: token random nonce for the commitmentB (private)
// pathB: the Merkle path for the commitmentB (private)

// - amountC:  the amount contained in the commitmentC (public)
// - commitmentC: the commitment (public)
// - publicKeyC: the public key of the commitmentC derived by hashing the Secret Key Sk of the commitmentC (private)
// - randomC: token random nonce (private)

// - amountD:  the amount contained in the commitmentD (public)
// - commitmentD: the commitment (public)
// - randomD: token random nonce (private)

def main(field[10] publicInput, private field secretKey, private field randomA, private field[32] pathA, private field randomB, private field[32] pathB, private field publicKeyC, private field randomC, private field randomD)->bool:
	
	// public input information 
	field amountA = publicInput[0]
    field nullifierA = publicInput[1]
    field rootA = publicInput[2]

	field amountB = publicInput[3]
    field nullifierB = publicInput[4]
    field rootB = publicInput[5]

	field amountC = publicInput[6]
	field commitmentC = publicInput[7]

	field amountD = publicInput[8]
	field commitmentD = publicInput[9]

	// check nullifierA
	// nullifier = H(amount|secretKey|random)
	u32[8] amountAU32 = unpack(amountA)
	u32[8] secretKeyU32 = unpack(secretKey)
	u32[8] randomAU32 = unpack(randomA)
	field temp = 0
	u32[8] padding = unpack(temp)

	u32[8] nullifierAResultU32 = sha256of1024(amountAU32, secretKeyU32, randomAU32, padding)
	field nullifierAResult = pack(nullifierAResultU32)

	// publicKey = H(secretKey)
	u32[8] publicKeyU32 = sha256of1024(secretKeyU32, padding, padding, padding)

	// commitment = H(amount|publicKey|random)
	u32[8] commitmentAU32 = sha256of1024(amountAU32, publicKeyU32, randomAU32, padding)

	// Prove that the commitment is in the Merkle tree
	u32[8] hashA = commitmentAU32
	for field i in 0..32 do
		hashA = sha256of1024(hashA, unpack(pathA[i]), padding, padding)
	endfor
	field rootAHash = pack(hashA)

	// check nullifierB
	// nullifier = H(amount|secretKey|random)
	u32[8] amountBU32 = unpack(amountB)
	u32[8] randomBU32 = unpack(randomB)

	u32[8] nullifierBResultU32 = sha256of1024(amountBU32, secretKeyU32, randomBU32, padding)
	field nullifierBResult = pack(nullifierBResultU32)

	// commitment = H(amount|publicKey|random)
	u32[8] commitmentBU32 = sha256of1024(amountBU32, publicKeyU32, randomBU32, padding)

	// Prove that the commitment is in the Merkle tree
	u32[8] hashB = commitmentBU32
	for field i in 0..32 do
		hashB = sha256of1024(hashB, unpack(pathB[i]), padding, padding)
	endfor
	field rootBHash = pack(hashB)

	// check commitmentC
	u32[8] amountCU32 = unpack(amountC)
	u32[8] publicKeyCU32 = unpack(publicKeyC)
	u32[8] randomCU32 = unpack(randomC)

	// commitment = H(amount|publicKey|random)
	u32[8] commitmentCresultU32 = sha256of1024(amountCU32, publicKeyCU32, randomCU32, padding)
	field commitmentCresult = pack(commitmentCresultU32)

	// check commitmentD
	u32[8] amountDU32 = unpack(amountD)
	u32[8] randomDU32 = unpack(randomD)

	// commitment = H(amount|publicKey|random)
	u32[8] commitmentDresultU32 = sha256of1024(amountDU32, publicKeyU32, randomDU32, padding)
	field commitmentDresult = pack(commitmentDresultU32)

	// check sum 
	// A + B = C + D
	field sumIn = amountA + amountB
	field sumOut = amountC + amountD

	return rootA == rootAHash && nullifierA == nullifierAResult && rootB == rootBHash && nullifierB == nullifierBResult && commitmentC == commitmentCresult && commitmentD == commitmentDresult && sumIn == sumOut


